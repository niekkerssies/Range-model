# -*- coding: utf-8 -*-
"""plots 13-06

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1itwl25OKTVbSAYBycplLn1UdvyY6yvJp

# 3. Plotting results

The summary_and_plot function takes the output dictionaries created by calling run_simulation, and creates visualizations and summaries of that output.

There's three types of plots that are created by this function. Type 1: plots where the x-axes represent the varying input parameter, and the y-axes represent network measure values. These are created by the "create_plot"  and "ceate_plot_null_range" functions. Type 2: plots that represent average diffusion over time per input parameter value. These visualize the SI and complex contagion processes (see script 1). Type 3: bar plots that visualize the number of "crossover" occurances in the potion task (see script 1), per input parameter value.

"Create_plot" is a subfunction used to generate the network properties (y-axis) vs. input parameter (x-axis) plots. First, a scatterplot is created in which points are results for single rounds (as explained above, these are time-averaged network properties over T timesteps, except for connectivity which is a simple count). If R=100, each input parameter value on the x axis will have 100 results. Second, a trend line is drawn connecting the averages across these R single-round measures. Third, a transparent area is created corresponding to 1.5 standard deviations around this average. The function takes as input:

-index number of the current subplot (a matplotlib object of 4 subplots axes[0] through axes [4] is created in summary_and_plot);

-the input argument of summary_and_plot "parameter_label", which records the variable that was varied in the run_simulation call;

-"round_number", the current value of the for-loop over rounds inside of which create_plot will be called in summary_and_plot;

-"title" and "param_values" which are also input arguments of summary_and_plot;

-the relevant output dictionary of run_simulation;

-the relavant summary statistics created earlier in the summary_and_plot function.

The final network structure graphs show both the range and the null results in a single graph. "Create_plot_null_range" function is there specifically to plot runs where the varying parameter is range. Because the corresponding null-model parameter is not range but _P(connect)_, these plots cannot strictly be plotted on the same x-axis. Instead, this function adds a 'second x-axis' against which the null results are plotted.

The "summary_and_plot" function unpacks the results from run_simulation in another series of nested for-loops (simply to reformat the {R:{i{value}} dictionaries to {i{R:{value}} dictionaries), and creates plots of the network and diffusion process measures.

The function takes as input variables:

-the results dictionaries from run_simulation;

-"title", a string describing the plotted results;

-"parameter_label", a string describing the input parameter variable that was used in the simulation run;

-"param_values": this is a list of all the values that were taken by the varying input parameter.

To plot the results, call the summary_and_plot function. The arguments are (results,title,parameter_label,param_values,print_summary=True). For results, simply put the 'data' object defined by the run_simulation call (the result of script 1). For title, you can create a description of the output plots; i usually put "Average network properties of communication and transmission graph under varying [varying parameter]." For parameter_label, put the name of the varying input parameter chosen in the simulation run: "Range","N","g",or "P". For param_values, create a list of which the entries correspond to the values taken by the varying parameter. For P, this is list(round(np.linspace(0,11,1),1)); for the other parameters, it's list(range([chosen maximum value])). Below are some example calls.
"""

import networkx as nx
import numpy as np
import random
import matplotlib.pyplot as plt
import math
import scipy
import seaborn
import pandas
import copy

plt.rcParams.update({'figure.figsize': (10, 10)})
#this just globally sets the figure size

def create_plot(index,axes,parameter_label,round_number,title,multirundict,stats_per_value,null):
  axes[index].set_title(f"{parameter_label} vs. {title}")

  averages = np.array([stats_per_value[value][0] for value in stats_per_value.keys()])
  standdevs = np.array([stats_per_value[value][1] for value in stats_per_value.keys()])

  if null==False:
    linecolor = 'blue'
    areacolor = 'lightsteelblue'
    dotcolor = 'cornflowerblue'
  if null:
    linecolor = 'red'
    areacolor = 'mistyrose'
    dotcolor = 'lightcoral'

  for round_number in range(len(multirundict)):
      x_values = stats_per_value.keys()
      y_values = [multirundict[round_number][value] for value in x_values]
      #Scatterplot of round average results of network properties:
      axes[index].scatter(x_values, y_values, color=dotcolor, alpha=0.3, s=2)

  #Plotting network property outcomes:
  axes[index].plot(x_values, averages, color=linecolor, label=parameter_label)
  axes[index].fill_between(x_values, averages - 1.5 * standdevs, averages + 1.5 * standdevs, color=areacolor, alpha=0.3)

  axes[index].set_xlabel(parameter_label)
  axes[index].set_ylabel(f'{title}')
  #axes[index].legend()

  return axes[index]

def create_plot_null_range(index,axes,parameter_label,round_number,second_title,multirundict,stats_per_value):
  ax = axes[index].twiny()

  averages = np.array([stats_per_value[value][0] for value in stats_per_value.keys()])
  standdevs = np.array([stats_per_value[value][1] for value in stats_per_value.keys()])

  for round_number in range(len(multirundict)):
      x_values = stats_per_value.keys()
      y_values = [multirundict[round_number][value][0] for value in x_values]
      #Scatterplot of round average results of network properties:
      ax.scatter(x_values, y_values, color='lightcoral', alpha=0.3, s=2)

  ax.plot(x_values, averages, color='red', label=parameter_label)
  ax.fill_between(x_values, averages - 1.5 * standdevs, averages + 1.5 * standdevs, color='mistyrose', alpha=0.3)
  ax.set_xlabel(parameter_label)

  return ax

def summary_stats(valuedict):
  avg = np.mean(valuedict)
  sd = np.std(valuedict)
  minval = np.min(valuedict)
  maxval = np.max(valuedict)
  return(avg,sd,minval,maxval)

def summary_and_plot(results,title,parameter_label,param_values,print_summary=True,potion=False):
  multirun_crossover, multirun_freq, multirun_fixation,multirun_freqAB,multirun_fixationAB,multirun_degree,multirun_clustering,multirun_connectedness,multirun_aspl,multirun_nr_components,multirun_largest_component, multirun_distribution, multirun_SWness,null_multirun_crossover,null_multirun_freq, null_multirun_fixation,null_multirun_freqAB,null_multirun_fixationAB, null_multirun_degree, null_multirun_clustering, null_multirun_connectedness,null_multirun_aspl,null_multirun_nr_components,null_multirun_largest_component, null_multirun_distribution, null_multirun_SWness = results

  deg_stats_per_value = {}
  cc_stats_per_value = {}
  conn_stats_per_value = {}
  aspl_stats_per_value = {}
  nrcomp_stats_per_value = {}
  lcomp_stats_per_value = {}
  distr_stats_per_value = {}
  SW_stats_per_value = {}

  null_deg_stats_per_value = {}
  null_cc_stats_per_value = {}
  null_conn_stats_per_value = {}
  null_aspl_stats_per_value = {}
  null_nrcomp_stats_per_value = {}
  null_lcomp_stats_per_value = {}
  null_distr_stats_per_value = {}
  null_SW_stats_per_value = {}

  for value in param_values:
    #again, if range is the varying variable, the null model varies pc between 0 and 1.
    if parameter_label == 'Range':
      if value <=10:
        nullvalue = list(np.round(np.linspace(0,1,11),1))[value]
    else:
      nullvalue = value
    #again, skip the N = 0 iteration:
    if parameter_label == 'N' and value == 0:
      continue

    #initialize the network measure objects:
    average_t_r = {}
    sd_t_r ={}
    min_t_r={}
    max_t_r={}

    degree_values = []
    clustering_values = []
    connectedness_values = []
    aspl_values = []
    nrcomp_values = []
    lcomp_values = []
    distr_values = []
    SW_values = []

    null_average_t_r = {}
    null_sd_t_r ={}
    null_min_t_r={}
    null_max_t_r={}

    null_degree_values = []
    null_clustering_values = []
    null_connectedness_values = []
    null_aspl_values = []
    null_nrcomp_values = []
    null_lcomp_values = []
    null_distr_values = []
    null_SW_values = []

    #For the network property vs. input parameter graphs, retrieve the round-average values (y in the plots) at the current parameter value (x in the plots).
    for round_number in range(len(multirun_degree)):
      degree_values.append(multirun_degree[round_number][value])
      clustering_values.append(multirun_clustering[round_number][value])
      connectedness_values.append(multirun_connectedness[round_number][value])
      aspl_values.append(multirun_aspl[round_number][value])
      nrcomp_values.append(multirun_nr_components[round_number][value])
      lcomp_values.append(multirun_largest_component[round_number][value])
      if multirun_distribution[round_number][value] != "NA":
        distr_values.append(multirun_distribution[round_number][value])
      if multirun_SWness[round_number][value] != "NA":
        SW_values.append(multirun_SWness[round_number][value])

      #Don't try to retrieve null results when g is the input parameter, because there aren't any
      if parameter_label != 'g':
        null_degree_values.append(null_multirun_degree[round_number][nullvalue])
        null_clustering_values.append(null_multirun_clustering[round_number][nullvalue])
        null_connectedness_values.append(null_multirun_connectedness[round_number][nullvalue])
        null_aspl_values.append(null_multirun_aspl[round_number][nullvalue])
        null_nrcomp_values.append(null_multirun_nr_components[round_number][nullvalue])
        null_lcomp_values.append(null_multirun_largest_component[round_number][nullvalue])
        if null_multirun_distribution[round_number][nullvalue] != "NA":
          null_distr_values.append(null_multirun_distribution[round_number][nullvalue])
        if null_multirun_SWness[round_number][nullvalue] != "NA":
          null_SW_values.append(null_multirun_SWness[round_number][nullvalue])

    # For each parameter value, calculate statistics over the 100 runs done at that parameter value.
    deg_stats_per_value.update({"degree_values": summary_stats(degree_values)})
    cc_stats_per_value.update({"clustering_values": summary_stats(clustering_values)})
    conn_stats_per_value.update({"clustering_values": summary_stats(clustering_values)})
    aspl_stats_per_value.update({"aspl_values": summary_stats(aspl_values)})
    nrcomp_stats_per_value.update({"nrcomp_values": summary_stats(nrcomp_values)})
    lcomp_stats_per_value.update({"lcomp_values": summary_stats(lcomp_values)})
    distr_stats_per_value.update({"distr_values": summary_stats(distr_values)})
    SW_stats_per_value.update({"SW_values": summary_stats(SW_values)})

    if parameter_label != 'g':
      null_deg_stats_per_value.update({nullvalue: summary_stats(null_degree_values)})
      null_cc_stats_per_value.update({nullvalue: summary_stats(null_clustering_values)})
      null_conn_stats_per_value.update({nullvalue: summary_stats(null_connectedness_values)})
      null_aspl_stats_per_value.update({nullvalue: summary_stats(null_aspl_values)})
      null_nrcomp_stats_per_value.update({nullvalue: summary_stats(null_nrcomp_values)})
      null_lcomp_stats_per_value.update({nullvalue: summary_stats(null_lcomp_values)})
      null_distr_stats_per_value.update({nullvalue: summary_stats(null_distr_values)})
      null_SW_stats_per_value.update({nullvalue: summary_stats(null_SW_values)})


  #Plots of input parameters(x) versus network structure outcomes (y):

  # Create 2 rows of four subplots
  fig, axes = plt.subplots(2, 4, figsize=(20, 12))
  axes = axes.flatten()

  axes[0] = create_plot(0,axes,parameter_label,round_number,'Average degree',multirun_degree, deg_stats_per_value,False)
  axes[1] = create_plot(1, axes, parameter_label, round_number, 'Clustering coefficient', multirun_clustering, cc_stats_per_value, False)
  axes[2] = create_plot(2, axes, parameter_label, round_number, 'Connected graphs', multirun_connectedness, conn_stats_per_value, False)
  axes[3] = create_plot(3, axes, parameter_label, round_number, 'Average shortest path length', multirun_aspl,aspl_stats_per_value , False)
  axes[4] = create_plot(4, axes, parameter_label, round_number, 'Number of components', multirun_nr_components, nrcomp_stats_per_value , False)
  axes[5] = create_plot(5, axes, parameter_label, round_number, 'Size of largest component', multirun_largest_component, lcomp_stats_per_value , False)
  axes[6] = create_plot(6, axes, parameter_label, round_number, 'Gini-coefficient of degree distribution',multirun_distribution, distr_stats_per_value , False)
  axes[7] = create_plot(7, axes, parameter_label, round_number, 'Small-world-ness', multirun_SWness,SW_stats_per_value , False)


  if parameter_label != 'g':

    if parameter_label == 'Range':
      null_label = 'P(connect)'

      ax0 = create_plot_null_range(0,axes,null_label,round_number,'P(connect)',null_multirun_degree,null_deg_stats_per_value)
      ax1 = create_plot_null_range(1,axes,null_label,round_number,'Clustering coefficient',null_multirun_clustering,null_cc_stats_per_value )
      ax2 = create_plot_null_range(2,axes,null_label,round_number,'Connected graphs',null_multirun_connectedness,null_conn_stats_per_value )
      ax3 = create_plot_null_range(3,axes,null_label,round_number,'Average shortest path length',null_multirun_aspl,null_aspl_stats_per_value )
      ax4 = create_plot_null_range(4,axes,null_label,round_number,'Number of components',null_multirun_nr_components,null_nrcomp_stats_per_value )
      ax5 = create_plot_null_range(5,axes,null_label,round_number,'Size of largest component',null_multirun_largest_component,null_lcomp_stats_per_value )
      ax6 = create_plot_null_range(6,axes,null_label,round_number,'Gini-coefficient of degree distribution',null_multirun_distribution, null_distr_stats_per_value )
      ax7 = create_plot_null_range(7,axes,null_label,round_number,'Small-world-ness',null_multirun_SWness,null_SW_stats_per_value )

    else:
      null_label = parameter_label

      axes[0] = create_plot(0,axes,null_label,round_number,'Average degree',null_multirun_degree,null_deg_stats_per_value,True)
      axes[1] = create_plot(1,axes,null_label,round_number,'Clustering coefficient',null_multirun_clustering, null_cc_stats_per_value,True)
      axes[2] = create_plot(2,axes,null_label,round_number,'Connected graphs',null_multirun_connectedness, null_conn_stats_per_value,True)
      axes[3] = create_plot(3,axes,null_label,round_number,'Average shortest path length',null_multirun_aspl, null_aspl_stats_per_value,True)
      axes[4] = create_plot(4,axes,null_label,round_number,'Number of components',null_multirun_nr_components, null_nrcomp_stats_per_value,True)
      axes[5] = create_plot(5,axes,null_label,round_number,'Size of largest component',null_multirun_largest_component, null_lcomp_stats_per_value,True)
      axes[6] = create_plot(6,axes,null_label,round_number,'Gini-coefficient of degree distribution',null_multirun_distribution, null_distr_stats_per_value,True)
      axes[7] = create_plot(7,axes,null_label,round_number,'Small-world-ness',null_multirun_SWness,null_SW_stats_per_value,True)

    plt.tight_layout()
    plt.show()

    #If potion task, this should be a nonempty list.
    if potion:

      #Potion task bar plots: on x, the varying parameter, on y amount of crossover events out of R rounds (given T timesteps).
      fig,axes = plt.subplots(1,2,figsize = (20,5))

      t_values = len(multirun_freq[1][1].keys())

      if parameter_label == 'Range':
        null_label = 'P(connect)'
        null_param_values = list(np.round(np.linspace(0,1,11),1))
      else:
        null_label = parameter_label
        null_param_values = param_values

      y = []
      y_null = []

      R = len(multirun_degree)

      crossover_instances_allrounds = {}
      average_time_per_value = {}
      total_average_excl = 0
      total_average_incl = 0

      null_crossover_instances_allrounds = {}
      null_average_time_per_value = {}
      null_total_average_excl = 0
      null_total_average_incl = 0

      #aim here: retrieve all crossover times per input value from multirun_crossover.
      for value in param_values:
        ycount = 0
        for round_number in range(R):
          crossover_instances = []
          #The value of "cross_time" is either an integer when crossover was reached, or a string stating it wasn't.
          #Here, we count how many times a crossover occured by counting integers, and add it to the summary statistic list "crossover_instances."
          currentvalue = multirun_crossover[round_number][value]
          if currentvalue != "crossover not reached":
            ycount += 1
            #list of crossover instances at i this round:
            crossover_instances.append(currentvalue)
        y.append(ycount)
        #list of crossover instances at i, all rounds:
        #crossover_instances_allrounds.update({value:crossover_instances})
        #average_time_per_value.update({value:np.mean(crossover_instances)})

      #Total average of time to crossover, including only runs that had succesful crossover:
      #total_average_excl = np.mean(average_time_per_value.items())

      #Total average including every run:

      for null_value in null_param_values:
        ycount_null = 0
        for round_number in range(R):
          null_crossover_instances = []
          currentvalue_null = null_multirun_crossover[round_number][null_value]
          if currentvalue_null != "crossover not reached":
            ycount_null += 1
            null_crossover_instances.append(currentvalue_null)
        y_null.append(ycount_null)
        #null_crossover_instances_allrounds.update({null_value:null_crossover_instances})
        #null_average_time_per_value.update({null_value:np.mean(null_crossover_instances.items())})

      #null_total_average_excl = np.mean(null_average_time_per_value.items())

      #Total average including every run:

      axes[0].bar(param_values,y)
      axes[0].set_xticks(param_values)
      axes[0].set_ylabel(f'Crossovers reached out of {R} rounds')
      axes[0].set_xlabel(f'{parameter_label}')
      max_y = max(y)
      axes[0].set_yticks(range(0, max_y + 1))

      if parameter_label =="Range":
        width = 0.08
      axes[1].bar(null_param_values,y_null,width=width)
      axes[1].set_ylabel(f'Crossovers reached out of {R} rounds')
      axes[1].set_xlabel(f'{null_label}')
      axes[1].set_xticks(null_param_values)
      max_y_null = max(y_null)
      axes[1].set_yticks(range(0, max_y_null + 1))
      #axes[1].set_xlim(0,1)

      plt.tight_layout()
      plt.show()

    else:
      fig,axes = plt.subplots(1,2,figsize = (20,5))

      t_values = len(multirun_freq[1][1].keys())
      R_values = len(multirun_degree)
      #nothing special about this dictionary or the indexes, just want to retrieve the number of rounds and timesteps

      #First plot, time on x, varying input parameter on y:

      for value in param_values:
        average_t_r = {}
        sd_t_r ={}
        min_t_r={}
        max_t_r={}

        for t in range(t_values):
          yparam_value_list = []

          for round_number in range(R_values):
            #at the following line it's giving me a keyerror: 2. Why?
            yparam_value_at_t = multirun_freq[round_number][value][t]

            #in the dictionary tracking the trait frequency at each timestep, retrieve that frequency at
            #the current parameter value, round and timestep.
            yparam_value_list.append(yparam_value_at_t)

          average_at_t = np.mean(yparam_value_list)
          sd_at_t = np.std(yparam_value_list)
          min_value_at_t = min(yparam_value_list)
          max_value_at_t = max(yparam_value_list)

          average_t_r.update({t:average_at_t})
          sd_t_r.update({t:sd_at_t})
          min_t_r.update({t:min_value_at_t})
          max_t_r.update({t:max_value_at_t})

        averages_per_value.update({value:average_t_r})
        sd_per_value.update({value:sd_t_r})
        min_per_value.update({value:min_t_r})
        max_per_value.update({value:max_t_r})

        xlist = [t for t in range(t_values)]
        ylist = []
        for t in range(t_values):
          #because this is is also how many y-values were taken
          ylist.append(averages_per_value[value][t])
        axes[0].plot(xlist,ylist,label=f'{parameter_label}= {value}')
        axes[0].set_xlabel('Timestep')
        axes[0].set_ylabel('Trait frequency')
        axes[0].set_title('Diffusion over time')
        axes[0].legend()

      #Second plot, null run:

      if parameter_label != 'g':

        if parameter_label =="Range":
          looplist = list(np.round(np.linspace(0,1,11),1))
        else:
          looplist = list(range(len(param_values)))

        for value in looplist:
          null_average_t_r = {}
          null_sd_t_r ={}
          null_min_t_r={}
          null_max_t_r={}

          for t in range(t_values):
            null_yparam_value_list = []

            for round_number in range(R_values):
              if parameter_label == 'N' and value == 0:
                continue
              null_yparam_value_at_t = null_multirun_freq[round_number][value][t]
              #in the dictionary tracking the trait frequency at each timestep, retrieve that frequency at
              #the current parameter value, round and timestep.
              null_yparam_value_list.append(null_yparam_value_at_t)

              null_average_at_t = np.mean(null_yparam_value_list)
              null_sd_at_t = np.std(null_yparam_value_list)
              null_min_value_at_t = min(null_yparam_value_list)
              null_max_value_at_t = max(null_yparam_value_list)

              null_average_t_r.update({t:null_average_at_t})
              null_sd_t_r.update({t:null_sd_at_t})
              null_min_t_r.update({t:null_min_value_at_t})
              null_max_t_r.update({t:null_max_value_at_t})

            null_averages_per_value.update({value:null_average_t_r})
            null_sd_per_value.update({value:null_sd_t_r})
            null_min_per_value.update({value:null_min_t_r})
            null_max_per_value.update({value:null_max_t_r})

          null_averages_per_value.update({value:null_average_t_r})
          null_sd_per_value.update({value:null_sd_t_r})
          null_min_per_value.update({value:null_min_t_r})
          null_max_per_value.update({value:null_max_t_r})

          xlist = [t for t in range(t_values)]
          ylist = []
          for t in range(t_values):
            if parameter_label == 'N' and value == 0:
              continue
            #because this is is also how many y-values were taken
            ylist.append(null_averages_per_value[value][t])
          if parameter_label == 'Range':
            parameter_label = 'P(connect)'
          axes[1].plot(xlist,ylist,label=f'{parameter_label}={value}')
          axes[1].set_xlabel('Timestep')
          axes[1].set_ylabel('Trait frequency')
          axes[1].set_title('Diffusion over time: null model')
          axes[1].legend()

        plt.tight_layout()
        plt.show()

#Call corresponding to example 1 in script 1: varying parameter is range between 0 and 10, diffusion process is SI.
summary_and_plot(datar,"Average network properties and diffusion under varying communication range",'Range',list(range(11)))

#Call corresponding to example 2: varying parameter is N between 0 and 100, diffusion process is potion task.
summary_and_plot(dataN,"Average network properties and potion task performance under varying communication range","N",list(range(101)))

#Call corresponding to example 3: varying parameter is g between 0 and 50, diffusion process is complex contagion.
summary_and_plot(datag,"Average network properties and diffusion under varying communication range","g",list(range(51)))