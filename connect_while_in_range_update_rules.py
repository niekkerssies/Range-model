# -*- coding: utf-8 -*-
"""Connect-while-in-range update rules

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_Gl89ZegWKlhT711d6e1ongAcjC4m-fz

In agent-based models, members of a population of agents execute a basic behavior each timestep: the update rule. This script defines the update rules for a) the range model and b) the null model. In the range model,  _N_ agents with communication range _r_ randomly move through a coordinate grid _gxg_, and add and remove links each timestep based on communication range. In the null model, _N_ each pair of nodes randomly connects each timestep with probability _pc_ and disconnects with probability _pd_. The intention is, first, to find the contrast in terms of network measures between a non-spatial model of network formation, and one where communication networks are formed based on position and movement in a space. Second, processes of information diffusion are simulated on top of these dynamic networks in order to demonstrate the consequences these differences can have on collective processes.

# Connect-while-in-range

The connect_while_in_range update rule has 3 steps: movement, information diffusion, and link updating.

To move, each agent chooses from a uniformly random distribution of its adjacent integer coordinates, including its current location. In other words, it selects a tile at random in its Moore neighborhood. To avoid agents sharing the same position, however, tiles currently occupied by other agents are excluded- as are positions out of bounds (below 0 or above g). If all tiles are occupied, the agent remains in place. (Note: this means that as N approaches gxg, the coordinate space becomes 'saturated,' reaching a state where each agent remains in place, each at a unique coordinate).

To diffuse, the current version of the model includes 3 possibilities: 1) SI diffusion, 2) complex contagion, 3) potion task. In SI diffusion, agents have the state "susceptible" (trait=0) or "infected" (trait=1). _N init_ initial agents are 'infected' at t=0, and at every timestep, each infected agent _i_ can diffuse to their network connections _j_ with probability _P(connect)_ ("pc" in the code). In complex contagion (Centola (...)), diffusion to agent _i_ in state S depends on the number of connected agents _j_ that are in state I. More specifically, the probability for _i_ to adopt state I in this simulation is (j(I)/N)w : the number of network neighbors in state I, j(I), divided by population size _N_, multiplied by a weight value _w_.

The potion task, based on (Derex and Boyd 2016) and existing models (Moser and Smaldino 2022, Migliano et al. 2020, (...)), is more specific. It simulates the progression of agents through a problem space with two 'trajectories' A and B through the combination of 'ingredients' to make a virtual 'potion.' There are a number of valid combinations of ingredients which produce a higher-level potion, which is associated with a higher score. The final, highest-score product requires the highest-level items from both trajectories. The original experiment found that more sparsely connected groups are succesful at exploring both trajectories and therefore finding the final item, while fully connected groups usually only optimized within on trajectory.

In the potion task simulation, agents are initialized with a starting inventory. Then, they select a random network neighbor, and the two agents randomly select 3 items from their inventory. Higher-scored items are more likely to be selected. Then, if this is a valid combination, both agents add the combination product item to their inventory. If a new valid combination was found, each of the two agents involved diffuse this new item to their network neighbors with probability _pdiff_.

Finally in the connect-while-in range update rule, agents update links. To do so, they check for each agent whether they are within a Euclidean distance of range _r_. They connect with those agents who are. If there were agents that were connected and have now moved out of range, they disconnect.

The function assumes as input the graph G (a networkx network object), initialized as empty graph at t=0, or as updated state (output of this function) afterwards. It also takes a value for grid size g such that the coordinate space is g x g, communication range r implemented as Euclidian distance, and the diffusion probability P.

Agents are updated in a random order each timestep.

# Connect at random: non-spatial null model

In the non-spatial model, instead of moving in a coordinate space, each timestep agents connect to each other agent with probability P (connect) which is set globally as the same for all agents. In other words, the networks are generated by an Erdos-Renyi [source] process for generating random graphs.

For link updating, in order to make the random graph network formation process dynamic and comparable to the range model, there is an additional parameter P(disconnect) which is set to the inverse of P(connect). This mimicks the connection probabilities of the agents in the range model. For randomly moving ranged agents, the probability of connecting to another agent is proportional to the percentage of the total area covered by the communication range. If range covers the whole coordinate space (i.e., for a circular Euclidean range and a square coordinate space, if (2Ï€r^2) : (g x g) >= 1, each agent always connect and networks are fully connected, mirroring the P(connect)=1 setting. If range does not cover the whole coordinate space, the area not covered by an agent's range is equal to the inverse of the area covered, mirroring the disconnect probability P(disconnect) = 1 - P(connect).

For some thoughts on "comparable" settings between the range and the null model, see "2. Run_simulation", where this function is actually called.

The function takes as input the G_null networkx object graph, 'pc' for P(connect), and P for the diffusion probability.
"""

import networkx as nx
import numpy as np
import random
import matplotlib.pyplot as plt
import math
import scipy
import seaborn
import pandas
import copy

combination_list = [
    ['a1','a3','b2'],
    ['A1','b1','b2'],
    ['A2','a1','b1'],
    ['A3','B3','B1'],
    ['a1','b1','b3'],
    ['B1','a2','a3'],
    ['B2','a2','b1'],
    ['B3','A3','B2']
]

sorted_combination_list = []

for entry in combination_list:
  sorted_combination_list.append(sorted(entry))

discovery_list = [
    ['A1','a',48,48],
    ['A2','a',109,109],
    ['A3','a',188,188],
    ['A4','a',358,358],
    ['B1','b',48,48],
    ['B2','b',109,109],
    ['B3','b',188,188],
    ['B4','b',358,358]
]


starting_inventory = [
    ["a1", 'a', 6, 0], #Potion, trajectory, value, score
    ["a2", 'a', 8, 0],
    ["a3", 'a', 10, 0],
    ["b1", 'b', 6, 0],
    ["b2", 'b', 8, 0],
    ["b3", 'b', 10, 0]]

def select_item(i, j, G):
    #first decide whether 1 or 2 items are picked
    one_or_two = random.randint(1, 2)

    #each agent assigns odds of item use based on current inventory scores:
    values_i = [item[2] for item in G.nodes[i]["inventory"]]
    values_j = [item[2] for item in G.nodes[j]["inventory"]]
    odds_i = [value / sum(values_i) for value in values_i]
    odds_j = [value / sum(values_j) for value in values_j]

    #Annoyingly,np.random.choice requires a 1-dimensional (non-nested) list (and random.choice doesn't
    #have a replacement parameter, and random.sample() doesn't have weights), so i can't just
    #select "selection_i" directly as one of the items in the inventory. Instead, i first make the
    #1d list of item IDs only:
    itemnames_i = [item[0] for item in G.nodes[i]["inventory"]]
    itemnames_j = [item[0] for item in G.nodes[j]["inventory"]]

    #then select from the item names:
    selectedvalue_i = np.random.choice(itemnames_i, size=one_or_two, replace=False, p=odds_i)
    selectedvalue_j = np.random.choice(itemnames_j, size=3 - one_or_two, replace=False, p=odds_j)

    #then set selected items to the full items with these itemnames:
    selection_i = [item for item in G.nodes[i]["inventory"] if item[0] in selectedvalue_i]
    selection_j = [item for item in G.nodes[j]["inventory"] if item[0] in selectedvalue_j]

    if one_or_two == 1:
      item1 = selection_i[0]
      item2 = selection_j[0]
      item3 = selection_j[1]
    elif one_or_two == 2:
      item1 = selection_i[0]
      item2 = selection_i[1]
      item3 = selection_j[0]

    return item1, item2, item3

def combine_items(combination,i,j,G):
  discovery = []
  discovered = False
  #check if valid combination
  item_ids = sorted([i[0] for i in combination])
  #sort both so order of items doesn't matter
  for entry in combination_list:
    if item_ids == sorted(entry):
      index = sorted_combination_list.index(item_ids)
      discovery = discovery_list[index]
      if discovery not in G.nodes[i]["inventory"] and discovery not in G.nodes[j]["inventory"]:
        discovered = True
      else:
        discovered = False
  return discovery, discovered

def diffuse(agent,discovery,pdiff,G):
  neighborlist = list(G.neighbors(agent))
  for neighbor in neighborlist:
    #check if discovered item in neighbor inventory
    if discovery not in G.nodes[neighbor]["inventory"]:
      #that neighbor adds the item with probability p: innovation diffusion probability.
      if random.random() > pdiff:
        G.nodes[neighbor]["inventory"].append(discovery)

def potion_task(G,pdiff,orderlist):
  #If you like you can define the lists and parameters given globally in "initialization"
  #here instead.
  for i in orderlist:
    #select partner:
    neighbors_list = list(G.neighbors(i))
    #If there are neighbors (list is non-empty), do the interaction:
    if neighbors_list:
      j = random.choice(neighbors_list)
      combination = select_item(i,j,G)
      discovery, discovered = combine_items(combination,i,j,G)
      if discovered:
        #Update inventories to include the discovered item (again as [Id,Trajectory,Value,Score])
        G.nodes[i]["inventory"].append(discovery)
        G.nodes[j]["inventory"].append(discovery)
        if pdiff > 0:
          diffuse(i,discovery,pdiff,G)
          diffuse(j,discovery,pdiff,G)
    scores = [item[3] for item in G.nodes[i]["inventory"]]
    #set score to highest valued current item
    G.nodes[i]["score"] = max(scores)
  return G


def connect_while_in_range(G, g, Range, P, compl = False, weight=0, potion = False, pdiff = 0):
  orderlist = random.sample(G.nodes,len(G.nodes))
  #random update order each timestep: take a random sample without replacement of the set of nodes of G,
  #of size N. In other words, arrange the nodes in a random order, which will be used to iterate over this timestep.

  #Movement:
  for i in orderlist:
    #list of positions currently occupied by other agents:
    occupied = list(G.nodes[j]["position"] for j in G.nodes)
    #retreive own current position:
    x, y = G.nodes[i]["position"]
    #Create list of positions in the Moore neighborhood:
    #(there's a smarter way of doing this with list comprehension, but that statement is about as long as just putting in the coordinates)
    neighborhood = [(x-1,y+1),(x,y+1),(x+1,y+1),(x-1,y),(x,y),(x+1,y),(x-1,y-1),(x,y-1),(x+1,y-1)]
    #Grid boundaries: if any of the available neighborhood positions would be below 0 or above g, delete them from the options:
    filtered_neighborhood = [(nx, ny) for nx, ny in neighborhood if 0 <= nx < g and 0 <= ny < g]
    #only move if position available (so if the list 'available' is non-empty), otherwise stay at current position:
    available = [pos for pos in filtered_neighborhood if pos not in occupied]
    if available:
      G.nodes[i]['position'] = random.choice(available)

  #Potion task:
  if potion:
    G = potion_task(G,pdiff,orderlist)

  else:

    #Complex contagion: transmission probability is a weighted sum of the number of neighbors with trait = 1.
    if compl:
      for i in orderlist:
        count = 0
        for j in G.neighbors(i):
            if G.nodes[j]['trait'] == 1:
                count += 1

        if G.nodes[i]['trait'] == 0:
            # Complex contagion: Probability of adoption depends on the count of adopting neighbors
            adoption_prob = P + ((count/len(G.nodes)) * weight)
            if random.random() < adoption_prob:
                G.nodes[i]['trait'] = 1
    else:

      #SI diffusion:
      for i in orderlist:
        for j in G.neighbors(i):
          if G.nodes[i]["trait"] == 1 and G.nodes[j]['trait'] == 0:
            if random.random() < P:
              G.nodes[j]["trait"] = 1
            if G.nodes[j]["trait"] == 1 and G.nodes[i]['trait'] == 0:
              if random.random() < P:
                G.nodes[i]["trait"] = 1

  #Link updating:
  for i in orderlist:
    for j in orderlist:
      if j > i:
        #if within range, create link; if an existing edge is now out of range, remove it.
        ij_distance = math.sqrt((G.nodes[j]["position"][0] - G.nodes[i]["position"][0]) ** 2 +
                                      (G.nodes[j]["position"][1] - G.nodes[i]["position"][1]) ** 2)
        if ij_distance <= Range:
          G.add_edge(i, j)
        elif G.has_edge(i, j):
          G.remove_edge(i, j)

  return G

def connect_at_random(G_null,pc,P,compl=False,weight=0,potion=False,pdiff=0):
  pdis = 1-pc
  orderlist = random.sample(G_null.nodes,len(G_null.nodes))

  if potion:
    G_null = potion_task(G_null,pdis,orderlist)

  else:

    #Complex contagion: transmission probability is a weighted sum of the number of neighbors with trait = 1.
    if compl:
      for i in orderlist:
        count = 0
        for j in G_null.neighbors(i):
            if G_null.nodes[j]['trait'] == 1:
                count += 1

        if G_null.nodes[i]['trait'] == 0:
            # Complex contagion: Probability of adoption depends on the count of adopting neighbors
            adoption_prob = P + ((count/len(G_null.nodes)) * weight)
            if random.random() < adoption_prob:
                G_null.nodes[i]['trait'] = 1
    else:

      #Diffusion
      for i in orderlist:
        for j in G_null.neighbors(i):
          if G_null.nodes[i]["trait"] == 1 and G_null.nodes[j]['trait'] == 0:
            if random.random() < P:
              G_null.nodes[j]["trait"] = 1
          if G_null.nodes[j]["trait"] == 1 and G_null.nodes[i]['trait'] == 0:
            if random.random() < P:
              G_null.nodes[i]["trait"] = 1

  #Link updating
  for i in orderlist:
    for j in orderlist:
      if j > i:
        if (not G_null.has_edge(i,j)) and (random.random() < pc):
          #connect if random value between 0 and 1 is lower than the connection chance.
          #At 1 it is always lower, at 0 it never is.
          G_null.add_edge(i, j)
        if G_null.has_edge(i, j) and random.random() < pdis:
          G_null.remove_edge(i, j)

  return G_null